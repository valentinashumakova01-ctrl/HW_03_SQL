CREATE TABLE customer (
    customer_id SERIAL PRIMARY KEY,
    first_name VARCHAR(100) NOT NULL,
    last_name VARCHAR(100),
    gender VARCHAR(20),
    DOB DATE,
    job_title VARCHAR(200),
    job_industry_category VARCHAR(100),
    wealth_segment VARCHAR(50),
    deceased_indicator VARCHAR(10) DEFAULT 'No',
    owns_car VARCHAR(10) DEFAULT 'No',
    address TEXT,
    postcode VARCHAR(20),
    state VARCHAR(100),
    country VARCHAR(100),
    property_valuation INTEGER
);

CREATE TABLE product (
    product_id INTEGER,
    brand VARCHAR(100),
    product_line VARCHAR(100),
    product_class VARCHAR(50),
    product_size VARCHAR(50),
    list_price DECIMAL(12,2),
    standard_cost DECIMAL(12,2)
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INTEGER NOT NULL,
    order_date DATE,
    online_order BOOLEAN,
    order_status VARCHAR(50) NOT NULL
);

CREATE TABLE order_items (
    order_item_id SERIAL PRIMARY KEY,
    order_id INTEGER NOT NULL,
    product_id INTEGER,
    quantity NUMERIC(10,1),
    item_list_price_at_sale NUMERIC(10,2),
    item_standard_cost_at_sale NUMERIC(10,2)
);


-- Распределение (количество) клиентов по сферам деятельности, отсортировав результат по убыванию количества
SELECT 
    job_industry_category,
    COUNT(*) AS customer_count
FROM customer
GROUP BY job_industry_category
ORDER BY customer_count DESC;


-- Общая сумма дохода (list_price*quantity) по всем подтвержденным заказам за каждый месяц по сферам деятельности клиентов
-- Отсортировать результат по году, месяцу и сфере деятельности
SELECT 
    EXTRACT(YEAR FROM o.order_date) AS year,
    EXTRACT(MONTH FROM o.order_date) AS month,
    c.job_industry_category,
    SUM(oi.item_list_price_at_sale * oi.quantity) AS total_revenue
FROM orders o
JOIN order_items oi ON o.order_id = oi.order_id
JOIN customer c ON o.customer_id = c.customer_id
WHERE o.order_status = 'Approved' 
GROUP BY 
    EXTRACT(YEAR FROM o.order_date),
    EXTRACT(MONTH FROM o.order_date),
    c.job_industry_category
ORDER BY year, month, c.job_industry_category;


-- Количество уникальных онлайн-заказов для всех брендов в рамках подтвержденных заказов клиентов из сферы IT
-- Включить бренды, у которых нет онлайн-заказов от IT-клиентов, — для них должно быть указано количество 0


SELECT 
    p.brand,
    COUNT(DISTINCT CASE WHEN o.online_order = true THEN o.order_id END) AS unique_online_orders
FROM product p
LEFT JOIN order_items oi ON p.product_id = oi.product_id
LEFT JOIN orders o ON oi.order_id = o.order_id 
    AND o.order_status = 'Approved'
LEFT JOIN customer c ON o.customer_id = c.customer_id 
    AND c.job_industry_category = 'IT'
GROUP BY p.brand
ORDER BY unique_online_orders DESC;

-- По всем клиентам: сумму всех заказов (общего дохода), максимум, минимум и количество заказов, 
-- а также среднюю сумму заказа по каждому клиенту
-- Отсортировать результат по убыванию суммы всех заказов и количества заказов
-- Выполнить двумя способами: используя только GROUP BY и используя только оконные функции
-- Сравнить результат

-- Способ с GROUP BY
SELECT 
    c.customer_id,
    c.first_name,
    c.last_name,
    SUM(oi.item_list_price_at_sale * oi.quantity) AS total_revenue,
    MAX(oi.item_list_price_at_sale * oi.quantity) AS max_order_amount,
    MIN(oi.item_list_price_at_sale * oi.quantity) AS min_order_amount,
    COUNT(o.order_id) AS order_count,
    AVG(oi.item_list_price_at_sale * oi.quantity) AS avg_order_amount
FROM customer c
LEFT JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN order_items oi ON o.order_id = oi.order_id
GROUP BY c.customer_id, c.first_name, c.last_name
ORDER BY total_revenue DESC NULLS LAST, order_count DESC NULLS LAST;

-- Способ с оконными функциями
SELECT DISTINCT
    c.customer_id,
    c.first_name,
    c.last_name,
    SUM(oi.item_list_price_at_sale * oi.quantity) OVER (PARTITION BY c.customer_id) AS total_revenue,
    MAX(oi.item_list_price_at_sale * oi.quantity) OVER (PARTITION BY c.customer_id) AS max_order_amount,
    MIN(oi.item_list_price_at_sale * oi.quantity) OVER (PARTITION BY c.customer_id) AS min_order_amount,
    COUNT(o.order_id) OVER (PARTITION BY c.customer_id) AS order_count,
    AVG(oi.item_list_price_at_sale * oi.quantity) OVER (PARTITION BY c.customer_id) AS avg_order_amount
FROM customer c
LEFT JOIN orders o ON c.customer_id = o.customer_id
LEFT JOIN order_items oi ON o.order_id = oi.order_id
ORDER BY total_revenue DESC NULLS LAST, order_count DESC NULLS LAST;

-- GROUP BY возвращает по одной строке на каждого клиента
-- Оконные функции сохраняют все исходные функции
-- В нашем случае вывод данных будет одинаковым, тк в customer_id значения не повторяются


-- Имена и фамилии клиентов с топ-3 минимальной и топ-3 максимальной суммой транзакций за весь период
-- Учесть клиентов, у которых нет заказов, приняв их сумму транзакций за 0
WITH customer_totals AS (
    SELECT 
        c.customer_id,
        c.first_name,
        c.last_name,
        COALESCE(SUM(oi.item_list_price_at_sale * oi.quantity), 0) AS total_amount
    FROM customer c
    LEFT JOIN orders o ON c.customer_id = o.customer_id
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY c.customer_id, c.first_name, c.last_name
),
ranked_customers AS (
    SELECT 
        customer_id,
        first_name,
        last_name,
        total_amount,
        RANK() OVER (ORDER BY total_amount DESC) AS rank_max,
        RANK() OVER (ORDER BY total_amount ASC) AS rank_min
    FROM customer_totals
)
SELECT 
    first_name,
    last_name,
    total_amount,
    'Max' AS rank_type
FROM ranked_customers
WHERE rank_max <= 3
UNION ALL
SELECT 
    first_name,
    last_name,
    total_amount,
    'Min' AS rank_type
FROM ranked_customers
WHERE rank_min <= 3
ORDER BY rank_type, total_amount DESC;

-- Вторые транзакции клиентов (если они есть) с помощью оконных функций
-- Если у клиента меньше двух транзакций, он не должен попасть в результат
WITH ordered_orders AS (
    SELECT 
        o.customer_id,
        o.order_id,
        o.order_date,
        ROW_NUMBER() OVER (PARTITION BY o.customer_id ORDER BY o.order_date, o.order_id) AS order_sequence
    FROM orders o
),
customer_second_orders AS (
    SELECT 
        oo.customer_id,
        oo.order_id,
        oo.order_date,
        c.first_name,
        c.last_name
    FROM ordered_orders oo
    JOIN customer c ON oo.customer_id = c.customer_id
    WHERE oo.order_sequence = 2
)
SELECT 
    customer_id,
    first_name,
    last_name,
    order_id,
    order_date
FROM customer_second_orders
ORDER BY customer_id;

-- Имена, фамилии и профессии клиентов, длительность максимального интервала (в днях) между двумя последовательными заказами
-- Исключить клиентов, у которых только один или меньше заказов
WITH ordered_orders AS (
    SELECT 
        o.customer_id,
        c.first_name,
        c.last_name,
        c.job_title,
        o.order_date,
        LAG(o.order_date) OVER (PARTITION BY o.customer_id ORDER BY o.order_date) AS prev_order_date,
        o.order_date - LAG(o.order_date) OVER (PARTITION BY o.customer_id ORDER BY o.order_date) AS days_between
    FROM orders o
    JOIN customer c ON o.customer_id = c.customer_id
),
customer_stats AS (
    SELECT 
        customer_id,
        first_name,
        last_name,
        job_title,
        MAX(days_between) AS max_days_between_orders,
        COUNT(*) AS total_orders,
        COUNT(days_between) AS calculated_intervals
    FROM ordered_orders
    GROUP BY customer_id, first_name, last_name, job_title
    HAVING COUNT(days_between) >= 1  -- Гарантирует минимум 2 заказа
)
SELECT 
    customer_id,
    first_name,
    last_name,
    job_title,
    max_days_between_orders
FROM customer_stats
ORDER BY max_days_between_orders DESC;


-- Топ-5 клиентов (по общему доходу) в каждом сегменте благосостояния (wealth_segment)
-- Вывести имя, фамилию, сегмент и общий доход. Если в сегменте менее 5 клиентов, вывести всех
WITH customer_wealth_revenue AS (
    SELECT 
        c.customer_id,
        c.first_name,
        c.last_name,
        c.wealth_segment,
        COALESCE(SUM(oi.item_list_price_at_sale * oi.quantity), 0) AS total_revenue
    FROM customer c
    LEFT JOIN orders o ON c.customer_id = o.customer_id
    LEFT JOIN order_items oi ON o.order_id = oi.order_id
    GROUP BY c.customer_id, c.first_name, c.last_name, c.wealth_segment
),
ranked_customers AS (
    SELECT 
        customer_id,
        first_name,
        last_name,
        wealth_segment,
        total_revenue,
        ROW_NUMBER() OVER (PARTITION BY wealth_segment ORDER BY total_revenue DESC) AS rank_in_segment
    FROM customer_wealth_revenue
)
SELECT 
    first_name,
    last_name,
    wealth_segment,
    total_revenue,
    rank_in_segment
FROM ranked_customers
WHERE rank_in_segment <= 5
ORDER BY wealth_segment, rank_in_segment;
